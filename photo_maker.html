<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>(MANIK-A-RNIKA) Photo Tool</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
*{box-sizing:border-box;margin:0;padding:0;font-family:'Segoe UI',sans-serif;}
body{min-height:100vh;display:flex;justify-content:center;align-items:flex-start;padding:15px;background:linear-gradient(120deg,#ff9a9e,#fad0c4,#a18cd1,#fbc2eb);background-size:400% 400%;animation:gradBG 15s ease infinite;}
@keyframes gradBG{0%{background-position:0% 50%;}50%{background-position:100% 50%;}100%{background-position:0% 50%;}}
.app{width:100%;max-width:450px;background:rgba(255,255,255,0.2);backdrop-filter:blur(18px);border-radius:24px;padding:20px;color:#fff;box-shadow:0 10px 30px rgba(0,0,0,0.25);}
header{text-align:center;margin-bottom:15px;}
header h2{font-size:1.8em;}
.controls{display:flex;flex-direction:column;gap:15px;margin-bottom:20px;}
.controls input[type="file"], .controls input[type="color"]{padding:10px;border-radius:12px;border:none;}
canvas{display:block;margin:10px auto;max-width:100%;border-radius:20px;box-shadow:0 8px 20px rgba(0,0,0,.3);}
.sheet-preview{margin-top:20px;text-align:center;}
button.download{padding:12px;border-radius:28px;font-weight:bold;font-size:16px;border:none;cursor:pointer;color:#fff;background:#3399ff;margin-top:5px;transition:0.2s;}
button.download:hover{transform:scale(1.05);}
</style>
</head>

<body>
<div class="app">
<header><h2>(MANIK-A-RNIKA) Photo Tool</h2></header>

<div class="controls">
  <input type="file" id="upload" accept="image/*">
  <input type="color" id="bgColor" value="#ffffff">
</div>

<canvas id="photoCanvas"></canvas>
<button class="download" onclick="downloadPhoto()">Download Photo</button>

<div class="sheet-preview">
  <canvas id="sheetCanvas"></canvas><br>
  <button class="download" onclick="downloadSheet()">Download Sheet</button>
</div>
</div>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/selfie_segmentation.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/esrgan"></script>

<script>
const upload = document.getElementById("upload");
const bgColorInput = document.getElementById("bgColor");
const photoCanvas = document.getElementById("photoCanvas");
const sheetCanvas = document.getElementById("sheetCanvas");

let imageBitmap = null;
let sheetCanvasData = null;

/* ===== LOAD IMAGE & AUTOMATIC PROCESS ===== */
upload.onchange = async e => {
  imageBitmap = await createImageBitmap(e.target.files[0]);
  processImage();
};

/* ===== AI SEGMENTATION ===== */
const segmenter = new SelfieSegmentation({locateFile:f=>`https://cdn.jsdelivr.net/npm/@mediapipe/selfie_segmentation/${f}`});
segmenter.setOptions({modelSelection:1});

segmenter.onResults(async results => {
  if(!imageBitmap) return;

  const w = imageBitmap.width;
  const h = imageBitmap.height;

  const tmpCanvas = document.createElement("canvas");
  tmpCanvas.width = w;
  tmpCanvas.height = h;
  const tmpCtx = tmpCanvas.getContext("2d");

  tmpCtx.fillStyle = bgColorInput.value;
  tmpCtx.fillRect(0,0,w,h);

  tmpCtx.save();
  tmpCtx.drawImage(imageBitmap,0,0,w,h);
  tmpCtx.globalCompositeOperation = "destination-in";
  tmpCtx.drawImage(results.segmentationMask,0,0,w,h);
  tmpCtx.restore();

  tmpCtx.save();
  tmpCtx.globalCompositeOperation = "destination-over";
  tmpCtx.fillStyle = bgColorInput.value;
  tmpCtx.fillRect(0,0,w,h);
  tmpCtx.restore();

  drawRoundedPhoto(tmpCanvas, photoCanvas, 30, 10); // thick black border

  // Generate full-res sheet and show inline
  sheetCanvasData = createSheet(photoCanvas, true);
  showSheetPreview();

  await upscalePhoto(photoCanvas);
});

/* ===== PROCESS PHOTO ===== */
function processImage(){
  if(!imageBitmap) return;
  segmenter.send({image:imageBitmap});
}

/* ===== DRAW ROUNDED PHOTO WITH BORDER ===== */
function drawRoundedPhoto(sourceCanvas, targetCanvas, radius, borderWidth){
  targetCanvas.width = sourceCanvas.width;
  targetCanvas.height = sourceCanvas.height;
  const tctx = targetCanvas.getContext("2d");

  tctx.clearRect(0,0,targetCanvas.width,targetCanvas.height);

  tctx.save();
  tctx.beginPath();
  tctx.moveTo(radius,0);
  tctx.lineTo(targetCanvas.width-radius,0);
  tctx.quadraticCurveTo(targetCanvas.width,0,targetCanvas.width,radius);
  tctx.lineTo(targetCanvas.width,targetCanvas.height-radius);
  tctx.quadraticCurveTo(targetCanvas.width,targetCanvas.height,targetCanvas.width-radius,targetCanvas.height);
  tctx.lineTo(radius,targetCanvas.height);
  tctx.quadraticCurveTo(0,targetCanvas.height,0,targetCanvas.height-radius);
  tctx.lineTo(0,radius);
  tctx.quadraticCurveTo(0,0,radius,0);
  tctx.closePath();
  tctx.clip();

  tctx.drawImage(sourceCanvas,0,0);
  tctx.restore();

  // draw border
  tctx.save();
  tctx.strokeStyle = "#000";
  tctx.lineWidth = borderWidth;
  tctx.beginPath();
  tctx.moveTo(radius,0);
  tctx.lineTo(targetCanvas.width-radius,0);
  tctx.quadraticCurveTo(targetCanvas.width,0,targetCanvas.width,radius);
  tctx.lineTo(targetCanvas.width,targetCanvas.height-radius);
  tctx.quadraticCurveTo(targetCanvas.width,targetCanvas.height,targetCanvas.width-radius,targetCanvas.height);
  tctx.lineTo(radius,targetCanvas.height);
  tctx.quadraticCurveTo(0,targetCanvas.height,0,targetCanvas.height-radius);
  tctx.lineTo(0,radius);
  tctx.quadraticCurveTo(0,0,radius,0);
  tctx.closePath();
  tctx.stroke();
  tctx.restore();
}

/* ===== CREATE 6x4 PHOTO SHEET ===== */
function createSheet(photoCanvas, forDownload=false){
  const cols = 6;
  const rows = 4;
  const gap = 20;          // space between photos
  const pageMargin = 30;    // space between sheet border and photos
  const pw = photoCanvas.width;
  const ph = photoCanvas.height;
  const fullWidth = cols*pw + (cols-1)*gap + pageMargin*2;
  const fullHeight = rows*ph + (rows-1)*gap + pageMargin*2;

  let sheet = forDownload ? document.createElement("canvas") : sheetCanvas;
  sheet.width = fullWidth;
  sheet.height = fullHeight;
  const ctx2 = sheet.getContext("2d");

  ctx2.fillStyle = "#fff";
  ctx2.fillRect(0,0,fullWidth,fullHeight);

  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      const x = pageMargin + c*(pw+gap);
      const y = pageMargin + r*(ph+gap);
      ctx2.drawImage(photoCanvas, x, y, pw, ph);
    }
  }

  if(!forDownload){
    const scale = Math.min(400/sheet.width, 300/sheet.height);
    sheetCanvas.width = sheet.width;
    sheetCanvas.height = sheet.height;
    sheetCanvas.style.width = sheet.width*scale + "px";
    sheetCanvas.style.height = sheet.height*scale + "px";
    sheetCanvas.getContext("2d").drawImage(sheet,0,0);
  }

  return sheet;
}

/* ===== SHOW SHEET INLINE ===== */
function showSheetPreview(){
  if(!sheetCanvasData) return;
  const ctx2 = sheetCanvas.getContext("2d");
  ctx2.clearRect(0,0,sheetCanvas.width,sheetCanvas.height);
  const scale = Math.min(400/sheetCanvasData.width, 300/sheetCanvasData.height);
  sheetCanvas.width = sheetCanvasData.width;
  sheetCanvas.height = sheetCanvasData.height;
  sheetCanvas.style.width = sheetCanvas.width*scale + "px";
  sheetCanvas.style.height = sheetCanvas.height*scale + "px";
  ctx2.drawImage(sheetCanvasData,0,0);
}

/* ===== DOWNLOAD PHOTO ===== */
function downloadPhoto(){
  if(!photoCanvas.width) return alert("No photo to download");
  const a = document.createElement("a");
  a.download = "photo.png";
  a.href = photoCanvas.toDataURL("image/png");
  a.click();
}

/* ===== DOWNLOAD SHEET ===== */
function downloadSheet(){
  if(!sheetCanvasData) return alert("Sheet not ready");
  const a = document.createElement("a");
  a.download = "photosheet.png";
  a.href = sheetCanvasData.toDataURL("image/png");
  a.click();
}

/* ===== OPTIONAL UPSCALER ===== */
async function upscalePhoto(canvas){
  try{
    const model = await esrgan.load();
    const tensor = tf.browser.fromPixels(canvas);
    const upscaled = await model.predict(tensor);
    await tf.browser.toPixels(upscaled, canvas);
  }catch(err){
    console.log("Upscaling failed:", err);
  }
}
</script>
</body>
</html>
